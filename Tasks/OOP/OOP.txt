
	Перед тем как приступить к непосредственной реализации проекта, необходимо продумать, 
каковы его основные элементы (сущности). Иными словами правильно разделить программу на объекты.
Чем объемней и содержательней будущая программа, тем больше элементов, взаимодействующих между собой.
И именно абстракция позволяет отсортировать главные, к примеру, обекты, характеристики и опустить второстепенные.
	
	В этой связи, имея программу с множеством объектов их реализации и взаимодействия, проявляется 
другой принцип, инкапсуляция. Определенный объект может содержать в себе сложную модель поведения, 
реализацию и взаимодействия с другими объектами, чем и обсусловлено содержание большого колличества функций.
Все те функции, к примеру, отвечающие за внутренную реализацию взаимодействия с другими объектами, можно 
пометить модификатором private, для сокрытия от других глаз и рук. Оставивь при этом некоторые методы, к примеру,  
непосредствено отвечающие за прямое взаимодействия с другими объектами, пометив модификатором public. 
Таким образм, все сложости объекта будут скрыты, а все необходимое для реализации и взаимодействия будет в общем доступе.
И именно такой принцип как инкапсуляция позволяет скрыть некоторую реализацию, улучшить качество взаимодейтвия, упрошая их.
Правильное использование инкапсуляции гарантирует, что ни один класс не может получить прямой доступ к внутренним данным нашего класса и, 
следовательно, изменить их без контроля с нашей стороны. Только через вызов методов того же класса, что и изменяемые переменные.
Резюмируюя, можно выделить, что такой принцип как инкапсуляция позволяет обеспечить:
1) валидность внутреннего состояния.
2) контроль передаваемых аргументов.
3) минимизацию ошибок при изменении кода классов.
4) определения способа взаимодействия нашего объекта со сторонними объектами.
	
	
	Когда класс содержить большую часть данных и методов, мы можем объявить его родителем нового класса, избежав лишнего дублирования кода.
К примеру, у нас есть несколько классов, имеющие некоторые схожие функции. Можно создать специальный класс, 
вынести эти функции в этот базовый класс и объявить те классы его наследниками. 
Т.е. указать в каждом классе, что у него есть класс-родитель – данный базовый класс.
Или же вместо вышеуказанного класса-родителя можно использовать, к примеру, в рамках класса Java, интерфейсы.
Можно скрыть не только различные реализации, но и даже сам класс, который ее содержит (везде в коде может фигурировать только интерфейс). 
Это позволяет очень гибко, прямо в процессе исполнения программы, подменять одни объекты на другие, меняя поведение объекта скрытно от всех классов, 
которые его используют.
В этой связи принципы наследования и полиморфизма взаимосвязаны между собой.
	Что казается такого метода как полиморфизм то это принцип в ООП, когда программа может использовать объекты с одинаковым интерфейсом без информации о внутреннем устройстве объекта.
Или же, если быть кратким, один интерфейс - множетсов реализаций.  Ярким примером полиморфизма может полсужить, если брать вышеупомянутый язык Java,
является интерфейс, вернее его реализация. К примеру, в интерфейсе находится один, общий метод, который оределяет поведение. Данное поведение присуще некоторым объектам.
Реализуя интерфейс, каждый объет использует общий со всеми метод. А вот каким образом, он уже определяет внутри себя.